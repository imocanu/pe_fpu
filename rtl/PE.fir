;buildInfoPackage: chisel3, version: 3.4.3, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit PE : 
  module MuxPE : 
    input clock : Clock
    input reset : Reset
    output io : {flip in0 : UInt<32>, flip in1 : UInt<32>, flip in2 : UInt<32>, flip in3 : UInt<32>, flip sel : UInt<2>, out : UInt<32>}
    
    reg sel_W : UInt, clock @[MuxPE.scala 22:22]
    sel_W <= io.sel @[MuxPE.scala 22:22]
    reg in0_W : UInt, clock @[MuxPE.scala 23:22]
    in0_W <= io.in0 @[MuxPE.scala 23:22]
    reg in1_W : UInt, clock @[MuxPE.scala 24:22]
    in1_W <= io.in1 @[MuxPE.scala 24:22]
    reg in2_W : UInt, clock @[MuxPE.scala 25:22]
    in2_W <= io.in2 @[MuxPE.scala 25:22]
    reg in3_W : UInt, clock @[MuxPE.scala 26:22]
    in3_W <= io.in3 @[MuxPE.scala 26:22]
    node _T = eq(sel_W, UInt<1>("h00")) @[MuxPE.scala 28:16]
    when _T : @[MuxPE.scala 29:3]
      io.out <= in0_W @[MuxPE.scala 30:12]
      skip @[MuxPE.scala 29:3]
    else : @[MuxPE.scala 33:3]
      node _T_1 = eq(sel_W, UInt<1>("h01")) @[MuxPE.scala 32:22]
      when _T_1 : @[MuxPE.scala 33:3]
        io.out <= in1_W @[MuxPE.scala 34:12]
        skip @[MuxPE.scala 33:3]
      else : @[MuxPE.scala 37:3]
        node _T_2 = eq(sel_W, UInt<2>("h02")) @[MuxPE.scala 36:22]
        when _T_2 : @[MuxPE.scala 37:3]
          io.out <= in2_W @[MuxPE.scala 38:12]
          skip @[MuxPE.scala 37:3]
        else : @[MuxPE.scala 41:3]
          io.out <= in3_W @[MuxPE.scala 42:12]
          skip @[MuxPE.scala 41:3]
    
  module PE : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip Xi_0 : UInt<32>, flip Yi_0 : UInt<32>, flip Xi_1 : UInt<32>, flip Yi_1 : UInt<32>, flip m_0_sel : UInt<2>, flip m_1_sel : UInt<2>, flip m_2_sel : UInt<2>, flip m_3_sel : UInt<2>, flip m_4_sel : UInt<2>, flip m_5_sel : UInt<2>, flip m_6_sel : UInt<2>, flip m_7_sel : UInt<2>, flip m_8_sel : UInt<2>, flip m_9_sel : UInt<2>, flip addsub_0_op : UInt<1>, flip addsub_1_op : UInt<1>, flip use_int : UInt<1>, flip round : UInt<3>, addsub_0_out : UInt<32>, addsub_1_out : UInt<32>}
    
    io.addsub_0_out is invalid @[PE.scala 40:19]
    io.addsub_1_out is invalid @[PE.scala 41:19]
    reg Xi_0 : UInt, clock @[PE.scala 46:22]
    Xi_0 <= io.Xi_0 @[PE.scala 46:22]
    reg Yi_0 : UInt, clock @[PE.scala 47:22]
    Yi_0 <= io.Yi_0 @[PE.scala 47:22]
    reg Xi_1 : UInt, clock @[PE.scala 49:22]
    Xi_1 <= io.Xi_1 @[PE.scala 49:22]
    reg Yi_1 : UInt, clock @[PE.scala 50:22]
    Yi_1 <= io.Yi_1 @[PE.scala 50:22]
    reg m_0_sel : UInt, clock @[PE.scala 55:25]
    m_0_sel <= io.m_0_sel @[PE.scala 55:25]
    reg m_1_sel : UInt, clock @[PE.scala 56:25]
    m_1_sel <= io.m_1_sel @[PE.scala 56:25]
    reg m_2_sel : UInt, clock @[PE.scala 57:25]
    m_2_sel <= io.m_2_sel @[PE.scala 57:25]
    reg m_3_sel : UInt, clock @[PE.scala 58:25]
    m_3_sel <= io.m_3_sel @[PE.scala 58:25]
    reg m_4_sel : UInt, clock @[PE.scala 59:25]
    m_4_sel <= io.m_4_sel @[PE.scala 59:25]
    reg m_5_sel : UInt, clock @[PE.scala 60:25]
    m_5_sel <= io.m_5_sel @[PE.scala 60:25]
    reg m_6_sel : UInt, clock @[PE.scala 61:25]
    m_6_sel <= io.m_6_sel @[PE.scala 61:25]
    reg m_7_sel : UInt, clock @[PE.scala 62:25]
    m_7_sel <= io.m_7_sel @[PE.scala 62:25]
    reg m_8_sel : UInt, clock @[PE.scala 63:25]
    m_8_sel <= io.m_8_sel @[PE.scala 63:25]
    reg m_9_sel : UInt, clock @[PE.scala 64:25]
    m_9_sel <= io.m_9_sel @[PE.scala 64:25]
    reg addsub_0_op : UInt<1>, clock @[PE.scala 66:29]
    addsub_0_op <= io.addsub_0_op @[PE.scala 66:29]
    reg addsub_1_op : UInt<1>, clock @[PE.scala 67:29]
    addsub_1_op <= io.addsub_1_op @[PE.scala 67:29]
    reg use_int : UInt<1>, clock @[PE.scala 69:25]
    use_int <= io.use_int @[PE.scala 69:25]
    reg round : UInt, clock @[PE.scala 70:25]
    round <= io.round @[PE.scala 70:25]
    reg m_0_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 82:24]
    reg m_1_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 83:24]
    reg m_2_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 84:24]
    reg m_3_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 85:24]
    reg m_4_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 86:24]
    reg m_5_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 87:24]
    reg m_6_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 88:24]
    reg m_7_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 89:24]
    reg m_8_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 90:24]
    reg m_9_out : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[PE.scala 91:24]
    reg m_0_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 93:26]
    reg m_1_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 94:26]
    reg m_2_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 95:26]
    reg m_3_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 96:26]
    reg m_4_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 97:26]
    reg m_5_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 98:26]
    reg m_6_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 99:26]
    reg m_7_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 100:26]
    reg m_8_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 101:26]
    reg m_9_s_out : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[PE.scala 102:26]
    inst m_0 of MuxPE @[PE.scala 108:19]
    m_0.clock <= clock
    m_0.reset <= reset
    m_0.io.sel <= m_0_sel @[PE.scala 109:14]
    m_0.io.in0 <= Xi_0 @[PE.scala 110:14]
    m_0.io.in1 <= Yi_0 @[PE.scala 111:14]
    m_0.io.in2 <= Xi_0 @[PE.scala 112:14]
    m_0.io.in3 is invalid @[PE.scala 113:14]
    
